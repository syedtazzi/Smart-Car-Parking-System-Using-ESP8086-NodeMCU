#define BLYNK_TEMPLATE_ID "TMPL67K2WPNwS"
#define BLYNK_TEMPLATE_NAME "Car Parking"
#define BLYNK_AUTH_TOKEN "YOUR_AUTH_TOKEN_HERE" // Give your Blynk token here

#define BLYNK_PRINT Serial

#include <ESP8266WiFi.h>
#include <BlynkSimpleEsp8266.h>
#include <Servo.h>
#include <Wire.h>
#include <LiquidCrystal_I2C.h>

char ssid[] = "SII"; // Give your Wi-Fi name here
char pass[] = "password"; // Give your Wi-Fi passward here

LiquidCrystal_I2C lcd(0x27, 16, 2);

Servo gate;

const int entrySensor = D3;
const int exitSensor = D4;
const int slot1 = D5;
const int slot2 = D6;
const int slot3 = D7;

unsigned long lastUpdate = 0;
unsigned long lastGateOperation = 0;
unsigned long lastLCDUpdate = 0;
const unsigned long gateDelay = 5000;
const unsigned long lcdUpdateInterval = 500;

// Debouncing variables for entry/exit sensors
unsigned long lastEntryDebounceTime = 0;
unsigned long lastExitDebounceTime = 0;
const unsigned long debounceDelay = 200;  // 200ms debounce time

int prevEntryState = HIGH;
int prevExitState = HIGH;
int stableEntryState = HIGH;
int stableExitState = HIGH;

int availableSlots = 0;

void setup() {
  Serial.begin(115200);
  delay(1000);
  
  Serial.println("\n\n=== Car Parking System Starting ===");
  
  Wire.begin(D2, D1);
  lcd.init();
  lcd.backlight();
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("Smart Parking");
  lcd.setCursor(0, 1);
  lcd.print("Initializing...");
  delay(2000);
  
  // Use INPUT_PULLUP for more stable readings
  pinMode(entrySensor, INPUT_PULLUP);
  pinMode(exitSensor, INPUT_PULLUP);
  pinMode(slot1, INPUT);
  pinMode(slot2, INPUT);
  pinMode(slot3, INPUT);
  
  gate.attach(D8);
  gate.write(0);
  
  Serial.println("Hardware initialized");
  
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("Connecting WiFi");
  
  WiFi.begin(ssid, pass);
  
  int attempts = 0;
  while (WiFi.status() != WL_CONNECTED && attempts < 20) {
    delay(500);
    Serial.print(".");
    lcd.setCursor(attempts % 16, 1);
    lcd.print(".");
    attempts++;
  }
  
  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("\nWiFi Connected!");
    Serial.print("IP: ");
    Serial.println(WiFi.localIP());
    
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("WiFi Connected!");
    lcd.setCursor(0, 1);
    lcd.print(WiFi.localIP());
    delay(2000);
    
    Blynk.config(BLYNK_AUTH_TOKEN);
    Blynk.connect();
    
    if (Blynk.connected()) {
      Serial.println("Blynk Connected!");
      lcd.clear();
      lcd.setCursor(0, 0);
      lcd.print("Blynk Connected");
      delay(1500);
    }
  } else {
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("WiFi Failed!");
    lcd.setCursor(0, 1);
    lcd.print("Check Settings");
  }
  
  // Read initial stable states
  stableEntryState = digitalRead(entrySensor);
  stableExitState = digitalRead(exitSensor);
  prevEntryState = stableEntryState;
  prevExitState = stableExitState;
  
  updateLCD();
}

void updateLCD() {
  int s1 = digitalRead(slot1);
  int s2 = digitalRead(slot2);
  int s3 = digitalRead(slot3);
  
  availableSlots = 0;
  if (s1 == HIGH) availableSlots++;
  if (s2 == HIGH) availableSlots++;
  if (s3 == HIGH) availableSlots++;
  
  lcd.clear();
  
  lcd.setCursor(0, 0);
  lcd.print("Available: ");
  lcd.print(availableSlots);
  lcd.print("/3");
  
  lcd.setCursor(0, 1);
  lcd.print("S1:");
  lcd.print(s1 == HIGH ? "E" : "F");
  lcd.print(" S2:");
  lcd.print(s2 == HIGH ? "E" : "F");
  lcd.print(" S3:");
  lcd.print(s3 == HIGH ? "E" : "F");
}

void showGateMessage(String message) {
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print(message);
  lcd.setCursor(0, 1);
  lcd.print("Gate Opening...");
}

void operateGate(String source) {
  if (millis() - lastGateOperation < gateDelay) {
    Serial.println("Gate cooldown active, ignoring...");
    return;
  }
  
  lastGateOperation = millis();
  Serial.print(">>> Gate opening (triggered by: ");
  Serial.print(source);
  Serial.println(")");
  
  showGateMessage(source);
  
  gate.write(90);
  delay(3000);
  gate.write(0);
  
  Serial.println(">>> Gate closed");
  
  updateLCD();
}

// Debounced reading function
int debounceRead(int pin, int &lastState, unsigned long &lastDebounceTime, int &stableState) {
  int reading = digitalRead(pin);
  
  // If the reading changed, reset the debounce timer
  if (reading != lastState) {
    lastDebounceTime = millis();
  }
  
  // If enough time has passed, accept the new reading
  if ((millis() - lastDebounceTime) > debounceDelay) {
    if (reading != stableState) {
      stableState = reading;
    }
  }
  
  lastState = reading;
  return stableState;
}

BLYNK_WRITE(V0) {
  if (param.asInt() == 1) {
    Serial.println("[BLYNK] Entry button pressed");
    operateGate("Entry Button");
  }
}

BLYNK_WRITE(V1) {
  if (param.asInt() == 1) {
    Serial.println("[BLYNK] Exit button pressed");
    operateGate("Exit Button");
  }
}

BLYNK_CONNECTED() {
  Serial.println("Blynk Connected!");
  Blynk.syncVirtual(V0, V1);
}

void loop() {
  if (Blynk.connected()) {
    Blynk.run();
  }
  
  // Update Blynk every second
  if (millis() - lastUpdate > 1000) {
    lastUpdate = millis();
    
    int s1 = digitalRead(slot1);
    int s2 = digitalRead(slot2);
    int s3 = digitalRead(slot3);
    
    Serial.print("Entry:");
    Serial.print(stableEntryState);
    Serial.print(" Exit:");
    Serial.print(stableExitState);
    Serial.print(" | Slots: ");
    Serial.print(s1); Serial.print(" ");
    Serial.print(s2); Serial.print(" ");
    Serial.println(s3);
    
    if (Blynk.connected()) {
      Blynk.virtualWrite(V2, s1 == LOW ? 255 : 0);
      Blynk.virtualWrite(V3, s2 == LOW ? 255 : 0);
      Blynk.virtualWrite(V4, s3 == LOW ? 255 : 0);
    }
  }
  
  // Update LCD less frequently to reduce flicker
  if (millis() - lastLCDUpdate > lcdUpdateInterval) {
    lastLCDUpdate = millis();
    updateLCD();
  }
  
  // Read sensors with debouncing
  int currentEntryState = debounceRead(entrySensor, prevEntryState, lastEntryDebounceTime, stableEntryState);
  int currentExitState = debounceRead(exitSensor, prevExitState, lastExitDebounceTime, stableExitState);
  
  // Detect STABLE state change from HIGH to LOW
  static int lastStableEntryState = HIGH;
  static int lastStableExitState = HIGH;
  
  // Entry sensor triggered
  if (lastStableEntryState == HIGH && currentEntryState == LOW) {
    Serial.println("!!! Entry sensor TRIGGERED (stable) !!!");
    
    if (Blynk.connected()) {
      Blynk.virtualWrite(V0, 1);
      delay(100);
    }
    
    operateGate("Entry Sensor");
    
    if (Blynk.connected()) {
      delay(100);
      Blynk.virtualWrite(V0, 0);
    }
  }
  lastStableEntryState = currentEntryState;
  
  // Exit sensor triggered
  if (lastStableExitState == HIGH && currentExitState == LOW) {
    Serial.println("!!! Exit sensor TRIGGERED (stable) !!!");
    
    if (Blynk.connected()) {
      Blynk.virtualWrite(V1, 1);
      delay(100);
    }
    
    operateGate("Exit Sensor");
    
    if (Blynk.connected()) {
      delay(100);
      Blynk.virtualWrite(V1, 0);
    }
  }
  lastStableExitState = currentExitState;
  
  delay(50);
}
